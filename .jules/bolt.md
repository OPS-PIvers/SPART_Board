## 2026-02-03 - [Widget Drag Optimization] **Learning:** Draggable widgets re-rendered their entire content on every pixel of movement because the parent passed a new `widget` object (with updated x/y). Standard `React.memo` failed because the `widget` prop reference changed. **Action:** Implemented a `InnerWidgetRenderer` component wrapped in `React.memo` with a custom comparison function. This function checks relevant widget properties but intentionally ignores `x` and `y` coordinates for most widgets, preventing re-renders during drag. Exceptions are made for position-aware widgets (like `catalyst`) which must re-render on move.

## 2026-02-03 - [DraggableWindow Direct DOM Manipulation] **Learning:** Even with `InnerWidgetRenderer` memoization, the `DraggableWindow` itself (and `GlassCard`) was re-rendering on every mouse move, and crucially, `updateWidget` was triggering a global `DashboardProvider` update, causing _all_ widgets in `DashboardView` to reconcile. **Action:** Refactored `DraggableWindow` to use a `dragState` ref and direct DOM manipulation (`style.left`, `style.top`, etc.) for non-position-aware widgets during drag/resize. `updateWidget` is now only called on `pointerup`, eliminating global re-renders during drag.

## 2026-02-03 - [Widget Render Avalanche] **Learning:** Interaction with _one_ active widget (e.g., Poll) triggered `session` updates in `useLiveSession`. Because `WidgetRenderer` received the entire `session` object as a prop, _every_ widget on the dashboard re-rendered whenever the active widget updated its config. **Action:** Refactored `WidgetRenderer` to accept granular `sessionCode` and `isGlobalFrozen` props instead of the full `session` object. This allows `React.memo` to skip re-renders for all non-active widgets during live session updates.

## 2026-02-03 - [Seating Chart Render Loop] **Learning:** `SeatingChartWidget` was re-rendering all furniture items during drag operations because the `assignedStudents` prop for each item was generated via `filter(...).map(...)` inside the render loop, creating a new array reference every time. This defeated `React.memo` on `FurnitureItemRenderer`. **Action:** Implemented a `studentsByFurnitureId` lookup map using `useMemo` and a stable `EMPTY_ARRAY` constant. This ensures that `assignedStudents` prop references remain stable unless assignments actually change, preventing O(N) re-renders during drag.
