## 2026-02-03 - [Widget Drag Optimization] **Learning:** Draggable widgets re-rendered their entire content on every pixel of movement because the parent passed a new `widget` object (with updated x/y). Standard `React.memo` failed because the `widget` prop reference changed. **Action:** Implemented a `InnerWidgetRenderer` component wrapped in `React.memo` with a custom comparison function. This function checks relevant widget properties but intentionally ignores `x` and `y` coordinates for most widgets, preventing re-renders during drag. Exceptions are made for position-aware widgets (like `catalyst`) which must re-render on move.

## 2026-02-03 - [DraggableWindow Direct DOM Manipulation] **Learning:** Even with `InnerWidgetRenderer` memoization, the `DraggableWindow` itself (and `GlassCard`) was re-rendering on every mouse move, and crucially, `updateWidget` was triggering a global `DashboardProvider` update, causing _all_ widgets in `DashboardView` to reconcile. **Action:** Refactored `DraggableWindow` to use a `dragState` ref and direct DOM manipulation (`style.left`, `style.top`, etc.) for non-position-aware widgets during drag/resize. `updateWidget` is now only called on `pointerup`, eliminating global re-renders during drag.

## 2026-05-24 - [Memoization of Widget Content] **Learning:** `WidgetRenderer` was re-rendering whenever `headerActions` (containing inline functions) or session data (e.g., student list) changed. This caused `DraggableWindow` to re-render, which in turn caused `ScalableWidget` (a heavy component) to re-render, even if the widget's configuration and dimensions were stable. **Action:** Memoized the `finalContent` (the `ScalableWidget` tree) inside `WidgetRenderer` using `useMemo` and stabilized the render prop callback. This allows `DraggableWindow` to re-render (updating the header) without forcing a re-render of the widget content.
