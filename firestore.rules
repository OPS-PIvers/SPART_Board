rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is an admin
    function isAdmin() {
      return request.auth != null &&
             request.auth.token.email != null &&
             exists(/databases/$(database)/documents/admins/$(request.auth.token.email.lower()));
    }

    // Admins collection
    match /admins/{email} {
      // Users can read their own admin record to check status
      // We use lower() to ensure case-insensitive matching
      allow read: if request.auth != null && 
                  request.auth.token.email != null && 
                  request.auth.token.email.lower() == email.lower();
      allow write: if false; // Only create via Firebase Console or Admin SDK
    }

    // Dashboards - users can only access their own dashboards in their subcollection
    match /users/{userId}/dashboards/{dashboardId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Rosters - users can only access their own rosters in their subcollection
    match /users/{userId}/rosters/{rosterId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Mini Apps - users can only access their own mini apps in their subcollection
    match /users/{userId}/miniapps/{appId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Notebooks - users can only access their own notebooks in their subcollection
    match /users/{userId}/notebooks/{notebookId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // PDFs - users can only access their own PDFs in their subcollection
    match /users/{userId}/pdfs/{pdfId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Quiz metadata - users can only access their own quiz metadata
    match /users/{userId}/quizzes/{quizId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // User data collection
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // User profile (building selection, etc.) — stored per user
    match /users/{userId}/userProfile/{profileId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Admin-only collections
    match /admin_settings/{document=**} {
      allow read, write: if isAdmin();
    }

    // Feature permissions - all authenticated users can read, only admins can write
    match /feature_permissions/{widgetType} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Global permissions - all authenticated users can read, only admins can write
    match /global_permissions/{featureId=**} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Admin backgrounds - authenticated users can read based on access level, only admins can write
    match /admin_backgrounds/{backgroundId} {
      // Admins can read everything
      allow read: if isAdmin();
      
      // Non-admins can read public backgrounds
      allow read: if request.auth != null && resource.data.accessLevel == 'public';
      
      // Non-admins can read beta backgrounds if they are explicitly in the beta list
      allow read: if request.auth != null && 
                  resource.data.accessLevel == 'beta' && 
                  request.auth.token.email.lower() in resource.data.betaUsers;

      allow write: if isAdmin();
    }

    // Global weather data
    match /global_weather/{document=**} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Instructional routines - all authenticated users can read, only admins can write
    match /instructional_routines/{routineId} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Shared boards - Anyone can read, only authenticated users can create. 
    // Authors and admins can update or delete.
    match /shared_boards/{shareId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null &&
        request.resource.data.originalAuthor == request.auth.uid;
      allow update, delete: if request.auth != null &&
        (resource.data.get('originalAuthor', null) == request.auth.uid || isAdmin());
    }

    // Sessions - Teacher owns it, Students can join
    match /sessions/{userId} {
      // Only authenticated users (including anonymous) can read sessions
      // This allows students to find sessions by code and listen to updates
      // TODO: For Phase 2/Production, implement Cloud Functions to validate
      // join codes server-side and remove this broad read permission.
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId; // Teacher controls it

      match /students/{studentId} {
        // Student session records store only a PIN — no PII.
        // The student's anonymous auth UID is used as the document ID so that
        // Firestore rules can validate ownership without server-side logic.
        // - Teacher (session owner) can read/write all student records
        // - Students can create and update only their own record (for heartbeats/disconnects)
        // - Only teacher and admins can delete records
        allow read: if request.auth != null &&
          (request.auth.uid == userId || isAdmin());
        allow create: if request.auth != null &&
          request.auth.uid == studentId;
        allow update: if request.auth != null &&
          (request.auth.uid == userId || isAdmin() ||
           request.auth.uid == studentId);
        allow delete: if request.auth != null &&
          (request.auth.uid == userId || isAdmin());
      }
    }

    // Quiz Sessions — Teacher owns it, authenticated students submit responses
    match /quiz_sessions/{teacherUid} {
      // Students need `list` access to find sessions by join code via a
      // collection-group query (getDocs + where('code', '==',...)).
      // Restricting enumeration fully requires a Cloud Function proxy; for now
      // we accept that authenticated users can list session documents.
      // `get` allows reading a single known document (students listening for
      // question index updates after joining).
      allow get: if request.auth != null;
      allow list: if request.auth != null;
      // Only the teacher (session owner) can create/update/delete the session document
      allow write: if request.auth != null && request.auth.uid == teacherUid;

      match /responses/{studentUid} {
        // Quiz response records store only a PIN — no student name or email.
        // Students join using anonymous Firebase Auth; their anonymous UID is
        // the document key. This satisfies request.auth != null without PII.
        //
        // - Teacher can read/write all responses (for monitoring)
        // - Students (anonymous or signed-in) can read/write their own response
        // - Admins have full access
        allow read: if request.auth != null &&
          (request.auth.uid == teacherUid ||
           request.auth.uid == studentUid ||
           isAdmin());
        allow create: if request.auth != null &&
          request.auth.uid == studentUid &&
          request.resource.data.studentUid == studentUid &&
          // Students cannot forge a score on creation
          request.resource.data.score == null;
        allow update: if request.auth != null && (
          // Teacher and admins can update any field
          request.auth.uid == teacherUid || isAdmin() ||
          // Students may only update their own response to submit answers.
          // pin and join metadata are immutable; only answers, status,
          // submittedAt, and tabSwitchWarnings may change.
          // score is never written by students.
          // tabSwitchWarnings may only increase (monotonic) to prevent tampering.
          (request.auth.uid == studentUid &&
           request.resource.data.studentUid == resource.data.studentUid &&
           request.resource.data.pin == resource.data.pin &&
           request.resource.data.joinedAt == resource.data.joinedAt &&
           request.resource.data.score == resource.data.score &&
           request.resource.data.diff(resource.data)
             .changedKeys().hasOnly(['answers', 'status', 'submittedAt', 'tabSwitchWarnings']) &&
           (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['tabSwitchWarnings']) ||
            request.resource.data.tabSwitchWarnings >= resource.data.get('tabSwitchWarnings', 0)))
        );
        allow delete: if request.auth != null &&
          (request.auth.uid == teacherUid || isAdmin());
      }
    }

    // Announcements - all authenticated users can read, only admins can create/update/delete
    match /announcements/{announcementId} {
      allow read: if request.auth != null;
      allow write: if isAdmin();

      // Poll votes subcollection — authenticated users can read live tallies and cast votes
      match /pollVotes/{optionIndex} {
        allow read: if request.auth != null;
        allow write: if request.auth != null;
      }
    }

    // Global Mini Apps - all authenticated users can read, only admins can write
    match /global_mini_apps/{appId} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Default deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}