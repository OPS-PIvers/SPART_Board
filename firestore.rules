rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is an admin
    function isAdmin() {
      return request.auth != null &&
             request.auth.token.email != null &&
             exists(/databases/$(database)/documents/admins/$(request.auth.token.email.lower()));
    }

    // Admins collection
    match /admins/{email} {
      // Users can read their own admin record to check status
      // We use lower() to ensure case-insensitive matching
      allow read: if request.auth != null && 
                  request.auth.token.email != null && 
                  request.auth.token.email.lower() == email.lower();
      allow write: if false; // Only create via Firebase Console or Admin SDK
    }

    // Dashboards - users can only access their own dashboards in their subcollection
    match /users/{userId}/dashboards/{dashboardId} {
      // All authenticated users can read their own dashboards
      allow read: if request.auth != null && request.auth.uid == userId;

      // Writes require additional validation for security-sensitive fields
      // Admin users have full write access, including widgets/proxyUrl configuration
      // Non-admin users: Client-side UI restricts proxyUrl editing to admins only,
      // but this can be bypassed by directly calling Firestore API, creating SSRF risk.
      //
      // SECURITY LIMITATION: While Firestore rules can technically access nested fields,
      // validating that NO widget in the widgets array has been modified to add/change
      // a proxyUrl field is complex and would require comparing every widget's config.
      // Blocking all widget modifications would prevent legitimate operations (add, remove,
      // configure, reposition), making the dashboard unusable for non-admin users.
      //
      // RECOMMENDED FOR PRODUCTION:
      // 1. Implement Cloud Functions with beforeWrite triggers to validate proxyUrl changes
      // 2. Move proxy logic to a backend service that doesn't accept user-provided URLs
      // 3. Use custom claims in security rules with Cloud Functions to enforce restrictions
      //
      // Current rule: Allow all authenticated users to read/write their own dashboards
      // with client-side validation providing first line of defense against SSRF.
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // User data collection
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Admin-only collections
    match /admin_settings/{document=**} {
      allow read, write: if isAdmin();
    }

    // Feature permissions - all authenticated users can read, only admins can write
    match /feature_permissions/{widgetType} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Admin backgrounds - authenticated users can read based on access level, only admins can write
    match /admin_backgrounds/{backgroundId} {
      // Admins can read everything
      allow read: if isAdmin();
      
      // Non-admins can read public backgrounds
      allow read: if request.auth != null && resource.data.accessLevel == 'public';
      
      // Non-admins can read beta backgrounds if they are explicitly in the beta list
      allow read: if request.auth != null && 
                  resource.data.accessLevel == 'beta' && 
                  request.auth.token.email.lower() in resource.data.betaUsers;

      allow write: if isAdmin();
    }

    // Default deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }
  }
}