## 2024-05-23 - Lazy Loading Widgets **Learning:** TypeScript's strict mode can be challenging when using `React.lazy` with named exports. The `LazyExoticComponent` type doesn't always align perfectly with `ComponentType` in strict checks, and the intermediate Promise result often results in `any`, triggering lint rules. **Action:** Use a helper function for named exports that handles the Promise resolution and explicitly casts the result to `React.LazyExoticComponent<React.ComponentType<any>>`, suppressing `no-explicit-any` where strictly necessary to satisfy the linter while maintaining runtime safety.

## 2024-05-23 - [Lazy Loading Types] **Learning:** When migrating a registry pattern to `React.lazy` with named exports, strict TypeScript setup requires updating the component type definition to include `React.LazyExoticComponent<T>`. It does not automatically infer assignability to `React.ComponentType<T>` in all contexts, especially when using a generic helper function. **Action:** Update type aliases to `React.ComponentType<P> | React.LazyExoticComponent<React.ComponentType<P>>` when lazy loading registry components.

## 2025-01-28 - [Widget Animation Loops] **Learning:** High-frequency animation loops (canvas `requestAnimationFrame` or audio processing) inside React components must decouple their loop logic from React state updates using `useRef`. Direct dependencies on rapidly changing state (like `volume` or `sensitivity`) in `useEffect` cause constant teardown and recreation of the loop/stream, leading to severe performance degradation. **Action:** Use `useRef` to store the latest value and read from it inside the loop, allowing the `useEffect` to run only once.

## 2025-02-19 - [Canvas Performance Optimization] **Learning:** High-frequency interactions on HTML Canvas (like drawing) driven by React state (`useState`) cause excessive re-renders (60fps), leading to lag. **Action:** Refactor to use `useRef` for transient state (like current path) and update the canvas imperatively during events (`mousemove`), only syncing to React state/config on completion (`mouseup`).

## 2026-01-26 - Debouncing Widget Updates **Learning:** Frequent state updates in widget settings (like textareas) can cause massive re-render storms if they propagate to the global DashboardContext. **Action:** Use `useDebounce` hook for text inputs in settings to decouple local UI state from global widget state updates.

## 2026-01-26 - Optimized Debounce Patterns **Learning:** When using debounced values in `useEffect` to trigger side effects (like API calls or context updates), carefully manage dependency arrays. Removing unstable dependencies (like new object references) prevents infinite loops, while syncing local state with external prop changes ensures data consistency. **Action:** Use `eslint-disable-next-line react-hooks/exhaustive-deps` judiciously when optimizing effect dependencies, and always pair it with a separate effect to handle external state synchronization.

## 2026-01-27 - List Rendering Optimization **Learning:** Large lists or lists with complex items (like Instructional Routines) can trigger expensive re-renders of all items when only one property changes. **Action:** Extract list items into standalone components wrapped in `React.memo` and use stable keys (IDs) instead of indices to minimize reconciliation overhead.
