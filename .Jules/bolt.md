## 2024-05-23 - Lazy Loading Widgets **Learning:** TypeScript's strict mode can be challenging when using `React.lazy` with named exports. The `LazyExoticComponent` type doesn't always align perfectly with `ComponentType` in strict checks, and the intermediate Promise result often results in `any`, triggering lint rules. **Action:** Use a helper function for named exports that handles the Promise resolution and explicitly casts the result to `React.LazyExoticComponent<React.ComponentType<any>>`, suppressing `no-explicit-any` where strictly necessary to satisfy the linter while maintaining runtime safety.

## 2024-05-23 - [Lazy Loading Types] **Learning:** When migrating a registry pattern to `React.lazy` with named exports, strict TypeScript setup requires updating the component type definition to include `React.LazyExoticComponent<T>`. It does not automatically infer assignability to `React.ComponentType<T>` in all contexts, especially when using a generic helper function. **Action:** Update type aliases to `React.ComponentType<P> | React.LazyExoticComponent<React.ComponentType<P>>` when lazy loading registry components.

## 2025-01-28 - [Widget Animation Loops] **Learning:** High-frequency animation loops (canvas `requestAnimationFrame` or audio processing) inside React components must decouple their loop logic from React state updates using `useRef`. Direct dependencies on rapidly changing state (like `volume` or `sensitivity`) in `useEffect` cause constant teardown and recreation of the loop/stream, leading to severe performance degradation. **Action:** Use `useRef` to store the latest value and read from it inside the loop, allowing the `useEffect` to run only once.

## 2025-02-19 - [Canvas Performance Optimization] **Learning:** High-frequency interactions on HTML Canvas (like drawing) driven by React state (`useState`) cause excessive re-renders (60fps), leading to lag. **Action:** Refactor to use `useRef` for transient state (like current path) and update the canvas imperatively during events (`mousemove`), only syncing to React state/config on completion (`mouseup`).

## 2025-02-27 - [Debounced Text Inputs] **Learning:** When debouncing text inputs that are synced with external props (controlled-like), a dual-effect pattern is required: one effect to sync local state from props (handling external updates), and another effect to trigger the expensive update when the debounced value changes. This prevents the immediate update from overwriting user input due to race conditions or rapid typing. **Action:** Use `useDebounce` with `useEffect` for syncing and updating, ensuring the update effect checks if the value actually changed to avoid loops.
