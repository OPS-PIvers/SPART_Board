## 2024-05-23 - Lazy Loading Widgets **Learning:** TypeScript's strict mode can be challenging when using `React.lazy` with named exports. The `LazyExoticComponent` type doesn't always align perfectly with `ComponentType` in strict checks, and the intermediate Promise result often results in `any`, triggering lint rules. **Action:** Use a helper function for named exports that handles the Promise resolution and explicitly casts the result to `React.LazyExoticComponent<React.ComponentType<any>>`, suppressing `no-explicit-any` where strictly necessary to satisfy the linter while maintaining runtime safety.

## 2024-05-23 - [Lazy Loading Types] **Learning:** When migrating a registry pattern to `React.lazy` with named exports, strict TypeScript setup requires updating the component type definition to include `React.LazyExoticComponent<T>`. It does not automatically infer assignability to `React.ComponentType<T>` in all contexts, especially when using a generic helper function. **Action:** Update type aliases to `React.ComponentType<P> | React.LazyExoticComponent<React.ComponentType<P>>` when lazy loading registry components.

## 2025-02-19 - [Debouncing Widget Settings] **Learning:** Widget settings inputs that drive global state (via `updateWidget`) cause massive re-render storms on every keystroke. Simple debouncing is insufficient if it depends on stale closure variables (like `config` or `items`). **Action:** Use `useDebounce` for the input value AND use a `useRef` to track the latest `config` inside the effect to ensure the delayed update uses the most current state without triggering infinite effect loops.
