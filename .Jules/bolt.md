## 2024-05-23 - Lazy Loading Widgets **Learning:** TypeScript's strict mode can be challenging when using `React.lazy` with named exports. The `LazyExoticComponent` type doesn't always align perfectly with `ComponentType` in strict checks, and the intermediate Promise result often results in `any`, triggering lint rules. **Action:** Use a helper function for named exports that handles the Promise resolution and explicitly casts the result to `React.LazyExoticComponent<React.ComponentType<any>>`, suppressing `no-explicit-any` where strictly necessary to satisfy the linter while maintaining runtime safety.

## 2024-05-23 - [Lazy Loading Types] **Learning:** When migrating a registry pattern to `React.lazy` with named exports, strict TypeScript setup requires updating the component type definition to include `React.LazyExoticComponent<T>`. It does not automatically infer assignability to `React.ComponentType<T>` in all contexts, especially when using a generic helper function. **Action:** Update type aliases to `React.ComponentType<P> | React.LazyExoticComponent<React.ComponentType<P>>` when lazy loading registry components.

## 2025-02-20 - High-Frequency Effect Thrashing **Learning:** High-frequency updates (like audio volume) passed as dependencies to `useEffect` cause the effect to tear down and recreate constantly (e.g., cancelling/restarting `requestAnimationFrame`). This kills performance. **Action:** Use `useRef` to store the volatile value and read `ref.current` inside the persistent animation loop, allowing the `useEffect` dependency array to remain empty.
