## 2024-05-23 - Lazy Loading Widgets **Learning:** TypeScript's strict mode can be challenging when using `React.lazy` with named exports. The `LazyExoticComponent` type doesn't always align perfectly with `ComponentType` in strict checks, and the intermediate Promise result often results in `any`, triggering lint rules. **Action:** Use a helper function for named exports that handles the Promise resolution and explicitly casts the result to `React.LazyExoticComponent<React.ComponentType<any>>`, suppressing `no-explicit-any` where strictly necessary to satisfy the linter while maintaining runtime safety.

## 2024-05-23 - [Lazy Loading Types] **Learning:** When migrating a registry pattern to `React.lazy` with named exports, strict TypeScript setup requires updating the component type definition to include `React.LazyExoticComponent<T>`. It does not automatically infer assignability to `React.ComponentType<T>` in all contexts, especially when using a generic helper function. **Action:** Update type aliases to `React.ComponentType<P> | React.LazyExoticComponent<React.ComponentType<P>>` when lazy loading registry components.

## 2024-05-24 - Expensive Computations in Render Loop **Learning:** `JSON.stringify` on large objects (like `widget.config`) inside a render loop (like `WidgetRenderer`) can cause significant performance degradation, especially during high-frequency updates like dragging. Even if the resulting string is used in a `useEffect`, the calculation happens on every render. **Action:** Wrap expensive derived values in `useMemo` and condition them on active flags (e.g., `isLive`) to skip computation when not needed.
