## 2024-05-23 - Lazy Loading Widgets **Learning:** TypeScript's strict mode can be challenging when using `React.lazy` with named exports. The `LazyExoticComponent` type doesn't always align perfectly with `ComponentType` in strict checks, and the intermediate Promise result often results in `any`, triggering lint rules. **Action:** Use a helper function for named exports that handles the Promise resolution and explicitly casts the result to `React.LazyExoticComponent<React.ComponentType<any>>`, suppressing `no-explicit-any` where strictly necessary to satisfy the linter while maintaining runtime safety.

## 2024-05-23 - [Lazy Loading Types] **Learning:** When migrating a registry pattern to `React.lazy` with named exports, strict TypeScript setup requires updating the component type definition to include `React.LazyExoticComponent<T>`. It does not automatically infer assignability to `React.ComponentType<T>` in all contexts, especially when using a generic helper function. **Action:** Update type aliases to `React.ComponentType<P> | React.LazyExoticComponent<React.ComponentType<P>>` when lazy loading registry components.

## 2025-01-28 - [Widget Animation Loops] **Learning:** High-frequency animation loops (canvas `requestAnimationFrame` or audio processing) inside React components must decouple their loop logic from React state updates using `useRef`. Direct dependencies on rapidly changing state (like `volume` or `sensitivity`) in `useEffect` cause constant teardown and recreation of the loop/stream, leading to severe performance degradation. **Action:** Use `useRef` to store the latest value and read from it inside the loop, allowing the `useEffect` to run only once.
